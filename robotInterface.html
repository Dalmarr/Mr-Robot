<!DOCTYPE html>
<!-- https://github.com/mrdoob/three.js/blob/master/examples/webgl_geometry_spline_editor.html
https://threejs.org/examples/#webgl_geometry_spline_editor 
https://discourse.threejs.org/t/select-object-on-click/23855


https://jasonchen1982.github.io/three.interaction.js/examples/interaction/
https://github.com/jasonChen1982/three.interaction.js/blob/master/examples/interaction/index.html
-->
<html lang="en">
	<head>
		<title>R O B O T</title>
		<meta charset="utf-8">
        
	</head>
	<body>

		<div id="infoOutput">
			Object Index: -
		</div>

		<!-- <input type="file" id="file-selector"> -->

		<script async src="js/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';
			import { OrbitControls } from './js//OrbitControls.js';
            import { GUI } from './js/lil-gui.module.min.js';

			const ENVIRONMENT_SCALE = 10;

			let camera, scene, renderer, controls, plane;
			const raycaster = new THREE.Raycaster();

			const mouse = new THREE.Vector2( );
			const amount = parseInt( window.location.search.substr( 1 ) ) || 10;
			const count = Math.pow( amount, 3 );
			const color = new THREE.Color();
            const objects = [];
			const position = [];
			const tracker = [];

			const loader = new THREE.FileLoader();
			
			THREE.Cache.enabled = true;

			let voxel;
			let objectIndex = 0;
            let transformControl;
			let currInstanceId = -1;

            const params = {
				moveObject: moveObject
			};


			init();
			// render();
            animate();

			//!!! TODO: figure out how to load files dynamically 

			// const fileSelector = document.getElementById('file-selector');
			// fileSelector.addEventListener('change', (event) => {
			// 	const fileList = event.target.files;
			// 	console.log(fileList);
			// 	loader.load(fileList[0], );
			// });

			//https://threejs.org/docs/#api/en/loaders/FileLoader.setResponseType
			//load a text file and output the result to the console
			loader.load(
				// resource URL
				'scanplan.txt',

				// onLoad callback
				function ( data ) {
					// output the text to the console
					// console.log( data )
					parsePlots( data );
					
				},

				

				// onProgress callback
				function ( xhr ) {
					console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
				},

				// onError callback
				function ( err ) {
					console.error( 'An error happened' );
				}
			);

			function parsePlots( data ){
				// console.log(data);

				var lines = data.split("\n");
				// console.log(lines);

				for(let i = 0; i < lines.length; i++){

					// console.log( lines[i] );

					var commandCode = lines[i].split(" ")[0];
					var instruction = lines[i].substring(lines[i].indexOf(" ") + 1);

					switch(commandCode) {
						case "p":
							position.push(instruction);
							break;
						case "pt":
							tracker.push(instruction);
							break;
					}
				}

				// console.log(position);
				// console.log(tracker);

				spawnBoxes();
				
			};

			function init() {

				camera = new THREE.PerspectiveCamera( 45, (window.innerWidth) / (window.innerHeight), 1, 100*ENVIRONMENT_SCALE );
				camera.position.set( 5*ENVIRONMENT_SCALE, 8*ENVIRONMENT_SCALE, 13*ENVIRONMENT_SCALE );
				camera.lookAt( 0, 0, 0 );

				scene = new THREE.Scene();
                scene.background = new THREE.Color( 0xf0f0f0 );

                // cubes
				// cubeMaterial = new THREE.MeshLambertMaterial( { color: 0xffffff, map: new THREE.TextureLoader().load( 'textures/square-outline-textured.png' ) } );
			    // const cubeGeo = new THREE.IcosahedronGeometry( 50, 3 );
				// const cubeGeo = new THREE.BoxGeometry( 50, 50, 50 );
				// const cubeMaterial = new THREE.MeshPhongMaterial( { color: 0xffffff } );
				// voxel = new THREE.InstancedMesh( cubeGeo, cubeMaterial, count );
			    // matrix = new THREE.Matrix4();

                // lighting for 3d objects
				const light = new THREE.HemisphereLight( 0xffffff, 0x888888 );
				light.position.set( 0, 1, 0 );
				scene.add( light );

                // grid 
                const gridHelper = new THREE.GridHelper( 9*ENVIRONMENT_SCALE, 5*ENVIRONMENT_SCALE );
				scene.add( gridHelper );

                // push objects to plane of grid
                const geometry = new THREE.PlaneGeometry( 50, 50 );
				geometry.rotateX( - Math.PI / 2 );
                plane = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { visible: false } ) );
                scene.add( plane );

				// gui
                const gui = new GUI();
                gui.add( params, 'moveObject' );
                gui.open();

				// // create boxes
				// spawnBoxes();
				

				// render commands
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

                // perspective controls
				controls = new OrbitControls( camera, renderer.domElement );
				controls.enableDamping = true;
				controls.enableZoom = true;
				controls.enablePan = false;

				window.addEventListener( 'resize', onWindowResize );

                document.addEventListener( 'click', onClick );
			}

			function spawnBoxes(){
				const cubeGeo = new THREE.BoxGeometry( 3, 3, 3 );
				const cubeMaterial = new THREE.MeshPhongMaterial( { color: 0xffffff } );
				voxel = new THREE.InstancedMesh( cubeGeo, cubeMaterial, count );
			    const matrix = new THREE.Matrix4();

				// console.log(position);

				//make random cubes <-- simulates input of coordinates
				for ( let i = 0; i < position.length; i++ ) {

					var cordXYZ = position[i].split(" ");

					// matrix.setPosition( Math.random() * 1000 - 500, Math.random() * 100, Math.random() * 1000 - 500 );
					matrix.setPosition(cordXYZ[0], cordXYZ[1], cordXYZ[2]);

					voxel.setMatrixAt( objectIndex, matrix );
					voxel.setColorAt( objectIndex, color );

					objectIndex ++;

				}
				scene.add(voxel);
			}

            function onClick( event ) {

				// event.preventDefault();
                mouse.x = ( (event.clientX) / (window.innerWidth) ) * 2 - 1;
				mouse.y = - ( (event.clientY) / (window.innerHeight) ) * 2 + 1;

				raycaster.setFromCamera( mouse, camera );

				const intersection = raycaster.intersectObject( voxel );
				if ( intersection.length > 0 ) {
					const instanceId = intersection[ 0 ].instanceId;
					currInstanceId = instanceId;
					
					voxel.setColorAt( currInstanceId, color.setHex( Math.random() * 0xffffff ) );
					voxel.instanceColor.needsUpdate = true;

					// moveObject();
					document.getElementById("infoOutput").innerHTML = "Object Index: " + instanceId + " --- position: " + position[instanceId] + " --- tracker: " + tracker[instanceId] ;
					
				}
            }
			

			// debugging function to prove that objects can be moved after creation
			function moveObject() {
				if(currInstanceId >= 0){
					// moves position to random location
					const matrix = new THREE.Matrix4();
					matrix.setPosition( Math.random() * 100 - 50, Math.random() * 1, Math.random() * 100 - 50 )
					voxel.setMatrixAt(currInstanceId, matrix)
					voxel.instanceMatrix.needsUpdate = true;
				}
			}


			function onWindowResize() {
				camera.aspect = (window.innerWidth / window.innerHeight);
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function animate() {
				requestAnimationFrame( animate );
				controls.update();
				// raycaster.setFromCamera( mouse, camera );

				render();
			}

			function render() {
				renderer.render( scene, camera );
			}

		</script>
	</body>
</html>