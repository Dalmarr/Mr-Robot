<!DOCTYPE html>
<!-- https://github.com/mrdoob/three.js/blob/master/examples/webgl_geometry_spline_editor.html
https://threejs.org/examples/#webgl_geometry_spline_editor 
https://discourse.threejs.org/t/select-object-on-click/23855


https://jasonchen1982.github.io/three.interaction.js/examples/interaction/
https://github.com/jasonChen1982/three.interaction.js/blob/master/examples/interaction/index.html
-->
<html lang="en">
	<head>
		<title>R O B O T</title>
		<meta charset="utf-8">
        
	</head>
	<body>

		<div id="infoOutput">
			Object Index
		</div>

		<script async src="js/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';
			import { OrbitControls } from './js//OrbitControls.js';
            import { GUI } from './js/lil-gui.module.min.js';

			let camera, scene, renderer, controls, plane;
			const raycaster = new THREE.Raycaster();

			const mouse = new THREE.Vector2( );
			const amount = parseInt( window.location.search.substr( 1 ) ) || 10;
			const count = Math.pow( amount, 3 );
			const color = new THREE.Color();
            const objects = [];

			let voxel;
			let objectIndex = 0;
            let transformControl;
			let currInstanceId = -1;

            const params = {
				moveObject: moveObject
			};


			init();
			// render();
            animate();

			function init() {

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.set( 500, 800, 1300 );
				camera.lookAt( 0, 0, 0 );

				scene = new THREE.Scene();
                scene.background = new THREE.Color( 0xf0f0f0 );

                // cubes
				// cubeMaterial = new THREE.MeshLambertMaterial( { color: 0xffffff, map: new THREE.TextureLoader().load( 'textures/square-outline-textured.png' ) } );
			    // const cubeGeo = new THREE.IcosahedronGeometry( 50, 3 );
				// const cubeGeo = new THREE.BoxGeometry( 50, 50, 50 );
				// const cubeMaterial = new THREE.MeshPhongMaterial( { color: 0xffffff } );
				// voxel = new THREE.InstancedMesh( cubeGeo, cubeMaterial, count );
			    // matrix = new THREE.Matrix4();

                // lighting for 3d objects
				const light = new THREE.HemisphereLight( 0xffffff, 0x888888 );
				light.position.set( 0, 1, 0 );
				scene.add( light );

                // grid 
                const gridHelper = new THREE.GridHelper( 1000, 20 );
				scene.add( gridHelper );

                // push objects to plane of grid
                const geometry = new THREE.PlaneGeometry( 1000, 1000 );
				geometry.rotateX( - Math.PI / 2 );
                plane = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { visible: false } ) );
                scene.add( plane );

				// gui
                const gui = new GUI();
                gui.add( params, 'moveObject' );
                gui.open();

				const cubeGeo = new THREE.BoxGeometry( 50, 50, 50 );
				const cubeMaterial = new THREE.MeshPhongMaterial( { color: 0xffffff } );
				voxel = new THREE.InstancedMesh( cubeGeo, cubeMaterial, count );
			    const matrix = new THREE.Matrix4();

				//make random cubes <-- simulates input of coordinates
				for ( let x = 0; x < 5; x++ ) {

					matrix.setPosition( Math.random() * 1000 - 500, Math.random() * 100, Math.random() * 1000 - 500 );

					voxel.setMatrixAt( objectIndex, matrix );
					voxel.setColorAt( objectIndex, color );

					objectIndex ++;

				}
				scene.add(voxel);

				// render commands
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

                // perspective controls
				controls = new OrbitControls( camera, renderer.domElement );
				controls.enableDamping = true;
				controls.enableZoom = true;
				controls.enablePan = false;

				window.addEventListener( 'resize', onWindowResize );

                document.addEventListener( 'click', onClick );
			}

            function onClick( event ) {

				// event.preventDefault();
                mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

				raycaster.setFromCamera( mouse, camera );

				const intersection = raycaster.intersectObject( voxel );
				if ( intersection.length > 0 ) {
					const instanceId = intersection[ 0 ].instanceId;
					currInstanceId = instanceId;
					
					voxel.setColorAt( currInstanceId, color.setHex( Math.random() * 0xffffff ) );
					voxel.instanceColor.needsUpdate = true;

					// console.log(voxel);
					// var position = new THREE.Vector3();
					// var x = voxel.setFromMatrixPosition(instanceId, matrix);
					// console.log(x);
					document.getElementById("infoOutput").innerHTML = "Object Index: " + instanceId;
					
				}
            }
			

			function moveObject() {
				if(currInstanceId >= 0){
					// moves position to random location
					const matrix = new THREE.Matrix4();
					matrix.setPosition( Math.random() * 1000 - 500, Math.random() * 100, Math.random() * 1000 - 500 )
					voxel.setMatrixAt(currInstanceId, matrix)
					voxel.instanceMatrix.needsUpdate = true;
				}
			}


			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function animate() {
				requestAnimationFrame( animate );
				controls.update();
				// raycaster.setFromCamera( mouse, camera );

				render();
			}

			function render() {
				renderer.render( scene, camera );
			}

		</script>
	</body>
</html>